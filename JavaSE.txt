

# Java

## JDK

java是跨平台的 可以在Windows Linux 等操作系统上实行 原因是依靠JVM来实现的

JDK（java delelopement kit） 包含的是 JRE 和 开发工具（javac，java等）

JRE （java runtime environment） 包括的是 JVM （java virtual Machine）

## 基础知识

### 转义符

```
\"  表示 "
\\ 	表示 \
\'  表示’
\r  表示 一个回车
```

## DOS命令

Disk Operating System 磁盘操作系统

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221215222233795.png" alt="image-20221215222233795" style="zoom: 80%;" />

### 相对路径

在abc/test100文件夹中访问 hello.txt文件

```
../../abc2文件夹/test200文件夹/hello.txt
../ 表示上一次级
```

### 绝对路径

```
d:\\abc2文件夹\test200文件夹\hello.txt
```

### dos常见的操作命令

#### 1 dir

```
dir是指查看文件夹的目录
比如查看 D:\学习资料 文件下的目录
dir D:\学习资料
```

#### 2 cd

```
change dir 改变目录位置
切换位置：比如说切换到 c盘
cd /D c:
绝对路径切换
cd d:\学习资料
```

#### 3 tree

```
查看文件下的树结构
```

#### 4 cls

```
清屏指令
```

#### 5 md

```
创建目录
```

#### 6 rd

```
删除目录
```

#### 7 copy

```
复制文件
```

#### 8 echo

```
输入内容到文件
```

#### 9 rd

```
删除目录
```

#### 10 move

```
剪切
```

#### 11 del

```
删除文件
```

## 自动类型转化

```java
自动类型转换是 低精度是可以向高精度转换
但是 低精度不能自动转成 高精度
int num = 'a' // char -> int
char = 1; // 是不允许的
```



## 面向对象编程

### 堆内存、栈内存、方法区

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221216092408163.png" alt="image-20221216092408163" style="zoom:67%;" />

**栈内存中存放的是自己创建的对象、堆内存中存放的是 new 的一个对象 方法区中存放的是类的方法和变量**



### 构造器

#### 1 无参构造

```java
public Car(){
        System.out.println("无参构造");
}

```

#### 2 有参构造

```javascript
public Car (int age){
        
        this.age = 20;
 }
```

### this

```java
//在对有参构造器中使用this，可以给类的变量名进行赋值操作
    public Car (int age){
        System.out.println(this);
        this.age = 20;
    }
```

## oop三大特性

### 封装

将一类东西进行封装起来，方便以后多个事件对其调用，简洁化编程

**对于成员变量使用private进行修饰，因此对每个成员变量设置一对getter和setter方法分别对其取值和赋值**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221216094734023.png" alt="image-20221216094734023" style="zoom:80%;" />



```java
import java.util.Scanner;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 0:01
 * @Version 1.0
 */

public class Test {
    public static void main(String[] args) {
    
        Scanner scanner = new Scanner(System.in);
        
        int age = scanner.nextInt();
        
        Car car = new Car();
        
        car.setAge(age);
    
        System.out.println(car.getAge());
        
        
    }
}
```

```java
/**
 * @ClassName Car
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 0:12
 * @Version 1.0
 */

public class Car {
    
    private int age;
    private String name;
    
    public Car(){
        System.out.println("无参构造");
    }
    
    public void setAge(int age){
        this.age = age;
    }
    
    public int getAge(){
        return this.age;
    }   
}
```



### 继承

#### 子类继承父类

```
子类继承父类导致子类可以使用父类的一些方法和属性
提高代码的复用性
```

#### toString方法

重写toString方法

```java
@Override
public String toString() {
    return "student1{" +
        "name='" + name + '\'' +
        ", age=" + age +
        ", sex='" + sex + '\'' +
        ", hobbay='" + hobbay + '\'' +
        '}';
}
```

```java
// 自带的 toString() 方法
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

#### 继承只支持单继承

**就是说一个子类只能继承一个父类，不能多继承**

#### 重写方法

```java
父类存在 method方法
子类继承了父类也需要 method方法
需要 重写一个父类的method方法
```

```
重写方法的时候加上@Override注解，当重写方法不符合要求就会报错，使用@Override更加方便和安全
```

```java
@Override
public String toString() {
    return "student1{" +
        "name='" + name + '\'' +
        ", age=" + age +
        ", sex='" + sex + '\'' +
        ", hobbay='" + hobbay + '\'' +
        '}';
}
```

### 多态

## static

### static成员变量

```java
// 静态变量是属于 类的
// 静态变量是可以通过对象访问 也可以通过类名访问
  public static int StudentNumber = 10;
// 成员变量
 private String name;
 private int age;
 public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
```

```java
/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 10:20
 * @Version 1.0
 */

public class Test {
    
    public static void main(String[] args) {
        
        // 静态变量是属于 类的
        // 静态变量是可以通过对象访问 也可以通过类名访问
        System.out.println(Student.StudentNumber);
        
        // 成员变量是属于 对象的
        // 成员变量是只能通过 对象访问
        Student student = new Student();
        
        student.setAge(20);
        student.setName("张三");
    
        System.out.println(student.getAge());
        System.out.println(student.getName());
        
    }
}

```

### static成员函数

```java
//static函数形式 是属于类的
public static int getMax(int a,int b){
    return a > b? a:b;
}
//成员函数 是属于 对象的
public int getmax(int a,int b){
    return a > b ? a :b; 
}
```

```java
// 在同一个类中调用static静态函数 可以省略 类对象
// 可以直接调用函数
int max = getMax(1,2);

// 必须通过对象调用

Student student = new Student();

max =student.getmax(2,8);
```

### 工具类

**使用static封装方法，在其他类中进行共享 不需要创建对象的**

```java
import java.util.Random;

/**
 * @ClassName Code
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 10:48
 * @Version 1.0
 */

public class Code {
    
    // 实现验证码登入
    public static String Code(int n){
        
        String code = "";
    
        Random random = new Random();
        
        String s = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSUVWXYZ";
        
        for(int i = 0; i < n; i++){
            int index = random.nextInt(s.length());
            code += s.charAt(index);
        }
        
        return code;
    }
    
}
```

```java
/**
 * @ClassName Student
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 10:20
 * @Version 1.0
 */

public class Student {
    
    public static void main(String[] args) {
    
        System.out.println(Code.Code(5));
        
    }
}
```

### 代码块

#### 静态代码块

```java
// static优先级 是高于main 
static{
	 System.out.println("静态代码块");
}

public static void main(String[] args) {
     System.out.println("main");
}
```

#### 对象代码块

```java
{
	System.out.println("对象代码块");
}
```

```java
//执行结果
静态代码块
main
对象代码块
```

#### 单例设计

##### 创建一个单例 方式一

```java
package SingleInstance;

/**
 * @ClassName Single
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 12:47
 * @Version 1.0
 */

public class Single {

    // 创建一个单例
    
    //1 将构造器进行私有化
    private Single(){
        
    }
    
    // 2 对外提供一个已经创建好的对象
    
    public static Single single = new Single();
    
}

```

##### 使用一个单例 方式一

```java
package SingleInstance;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 12:49
 * @Version 1.0
 */

public class Test {
    
    public static void main(String[] args) {
        
        Single single = Single.single;
    
        System.out.println(single);
        
        Single single1 = Single.single;
    
        System.out.println(single1);
    }
}

```

##### 创建一个单例 方式二

```java
public class Single{
    
    
    private static Single single;
    
    // 将 Single 进行私有化
    private Single(){
        
    }
    
    public static Single getInstance(){
        if (single == null) {
            return single = new Single();
        }
        return single;
    }
    
}
```



##### 使用一个单例 方式二

```java
Single single = Single.getInstance();

System.out.println(single);

Single single1 = Single.getInstance();

System.out.println(single1);
```



## final

**final 对变量，方法，类机进行修饰**

### 修饰类

```java
// final 定义的类
final class Animal{
    
   private String name;
   private int age;
    
}
// 不能继承final所继承的类 
class dog extends Animal{
    
}
```

### 修饰变量

```
对final修饰的变量 是只能进行一次赋值 不能进行二次赋值操作
```



```java
public class Test {
    
    public static void main(String[] args) {
        
        // 创建一个对象
        Animal animal = new Animal();
    
        System.out.println(animal.msg);
        
        // 修改 animal的 msg 
        // 报错
        animal.msg = "hello java";
    }
}

final class Animal{
    
   private String name;
   private int age;
   
   final public String msg = "hello";
    
}
```

### 修饰方法

```
对 父类中final修饰的方法 在子类中是不能进行重写的
```



```java
class Animal{
    
   private String name;
   private int age;
   
   final public String msg = "hello";
   
   final public void say(){
       System.out.println("hello world");
   }
    
}

class dog extends Animal{
    
    @Override
    public void say(){
        
    }
}

```

## 常量

```
通过final static 修饰的变量是常量
```



```java
public final static Name = "zs"
```

## 枚举类

```java
package Enum;

public enum Season {
    
    SPRING,SUMMER,AUTUMN,WINTER;
}
```

## 抽象类和抽象方法

### 抽象类

```java
abstract class Animal
```

### 抽象方法

```java
 public abstract void say();
```

```java
abstract class Animal{
    // 定义了一个抽象方法
    // 类就必须定义成抽象类
    public abstract void say();
    
}

//当 一个类继承了父类之后 
// 这个类就必须 要重写 父类总 抽象方法
class Dog extends Animal{
    
    @Override
    public void say() {
        
    }
}
```

## 模板方法模式

```java
使用抽象方法 实现模板(template)
模板方法建议 使用 final重写
    final 修饰方式  放置被修改
```

```java
package template;

/**
 * @ClassName Student
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 17:03
 * @Version 1.0
 */

public abstract class Student {
    // 形成了一个 模板
    public void Wirte(){
    
        System.out.println("开始阶段");
        
        // 正文
    
        System.out.println(writeMain());
    
        System.out.println("结束阶段");
    }
    
    public abstract String writeMain();
    
}
```

```java
package template;

/**
 * @ClassName Student_child
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 17:02
 * @Version 1.0
 */

// 子类继承 模板父类 只要完成 模板中没有完成部分
public class Student_child extends Student{
    @Override
    public String writeMain() {
        String str = "小学生正文部分";
        return str;
    }
}
```

```java
package template;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 17:01
 * @Version 1.0
 */

public class Test {
    
    public static void main(String[] args) {
        
        Student_child student_child = new Student_child();
    
        student_child.Wirte();
    
        System.out.println("--------------------");
        
        Student_high student_high = new Student_high();
        
        student_high.Wirte();
    
    }
}
```

## 接口

类的继承中只能是单一继承，但是继承接口中是可以继承多个接口的

```java
// 接口中的定义
public interface Interface {
    
    // 接口中的变量 是 常量
    public static final String Name = "zs";
    // 接口中的方法 是 抽象方法
    public abstract void say();
    
}
```

```java
// 由于接口体现规范思想 于是 可以省略 关键词/修饰词

public interface Interface {
    
    // 接口中的变量 是 常量
    String Name = "zs";
    // 接口中的方法 是 抽象方法
    void say();
    
}
```

## 多态

```java
多种形态
将子类的对象赋值给父类
```

```java
package 多态;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 18:33
 * @Version 1.0
 */

public class Test {
    
    public static void main(String[] args) {
    
        Dog dog = new Dog();
    
        System.out.println(dog);
        
        Animal dog1 = new Dog();
    
        System.out.println(dog1);
        
    }
}

class  Animal{
    
    private int age;
    
    @Override
    public String toString() {
        return "Animal{" +
                "age=" + age +
                '}';
    }
}

class Dog extends Animal{
    
    private String name = "zs";
    
    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

## Date

### 无参构造器

```java
// Datae 构造器 获取当前时间
Date data = new Date();

System.out.println(data);
```

### 获取时间函数

```java
long time = data.getTime();
System.out.println(time);
```

### 有参构造器

```java
time = time - 1000000000;
Date data1 = new Date(time);
```

### 时间设定

```java
data1.setTime(time);
    
System.out.println(data1.getTime());
```

## SimpleDateFormat

### format函数

```java
SimpleDateFormat simpleDateFormat = new SimpleDateFormat();

String string = simpleDateFormat.format(date);

System.out.println(string);
```

```java
Date date = new Date();

System.out.println(date);

long time = date.getTime();

System.out.println(simpleDateFormat.format(time));
```

### 无参构造函数

```
默认的 格式是 YYYY-MM-DD HH:MM:SS
```

### 有参构造函数

```java
  // 格式化设置 将时间表示 出来的 形式是怎么样的
  SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy~mm!dd HH!mm!ss");
```

### parse函数

```
设置格式 要与String的 格式一致 否者 throw 异常
```



```java
String star = "2021-12-10 00:00:00";

Date d = simpleDateFormat.parse(star);

System.out.println(d);
```

## Calendar类

```
创建日历的一个类
```



## Collection

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221216192237813.png" alt="image-20221216192237813" style="zoom:80%;" />

### 迭代器使用

```java
package Collection;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 19:25
 * @Version 1.0
 */

public class Test {
    
    public static void main(String[] args) {
    
        Collection<Integer> collection = new ArrayList<>();
        
        for(int i = 0 ; i < 10; i++){
            collection.add(i);
        }
    
        Iterator<Integer> iterator = collection.iterator();
        
        while(iterator.hasNext()){
            
            Integer it = iterator.next();
            System.out.println(it);
        }
        
    }
}
```

### 加强foreach

```java
package Collection;

import java.util.ArrayList;
import java.util.Collection;

/**
 * @ClassName Foreach
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 19:29
 * @Version 1.0
 */

public class Foreach {
    
    public static void main(String[] args) {
    
        // Collection 集合使用
        Collection<Integer> collection = new ArrayList<>();
        
        // 输入存储
        for(int i = 0 ; i < 100; i++){
            collection.add(i);
        }
    
        // foreach 输出
        for (Integer it:collection) {
            System.out.println(it);
        }
    }
}

```

### Set

#### Hashset

```java
package Collection.Set;

import java.util.HashSet;
import java.util.Set;

/**
 * @ClassName Hashset
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 20:03
 * @Version 1.0
 */

public class Hashset {
    
    public static void main(String[] args) {
       
        // 无须 无索引 无排序
        Set<String> set = new HashSet<>();
    
        set.add("Java");
        set.add("Java");
        set.add("MySQL");
        set.add("MySQL");
        set.add("HTML");
        set.add("JavaScript");
        set.add("JavaScript");
    
        System.out.println(set);
    }
}
```

#### LinkedHashset

```java
package Collection.Set;

import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * @ClassName Hashset
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 20:03
 * @Version 1.0
 */

public class Hashset {
    
    public static void main(String[] args) {
       
        // 有须 无索引 无排序 顺序是按照加入的顺序排列 
        Set<String> set = new LinkedHashSet<>();
       
        set.add("MySQL");
        set.add("MySQL");
        set.add("Java");
        set.add("Java");
        set.add("HTML");
        set.add("AavaScript");
        set.add("AavaScript");
    
        System.out.println(set);
    }
}

```

### TreeSet

```java
package Collection.Set;

import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.TreeSet;

/**
 * @ClassName Hashset
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 20:03
 * @Version 1.0
 */

public class Hashset {
    
    public static void main(String[] args) {
       
        // 无序 无索引 排序
        Set<String> set = new TreeSet<>();
       
        set.add("MySQL");
        set.add("MySQL");
        set.add("Java");
        set.add("Java");
        set.add("HTML");
        set.add("AavaScript");
        set.add("AavaScript");
    
        System.out.println(set);
    }
}

```

## Map

![image-20221216203903132](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221216203903132.png)

### HashMap

```java
package Map;

import java.util.HashMap;
import java.util.Map;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 20:30
 * @Version 1.0
 */

public class Test {
    
    public static void main(String[] args) {
        
        // 无序 不重复 不排序
        Map<Character,Integer>  map = new HashMap<>();
    
        map.put('E',10);
        map.put('B',20);
        map.put('C',30);
        map.put('D',40);
    
        System.out.println(map);
        // map 迭代输出
        // for (Character ch: map.keySet()) {
        //     System.out.print(ch + " "); 
        //     Integer value = map.get(ch);
        //     System.out.println(value);
        // }
    }
}
```

### LinkedHashmap

```
package Map;

import java.util.HashMap;
import java.util.Map;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 20:30
 * @Version 1.0
 */

public class Test {
    
    public static void main(String[] args) {
        
        // 有序 不重复 不排序
        Map<Character,Integer>  map = new LinkedhashMap<>();
    
        map.put('E',10);
        map.put('B',20);
        map.put('C',30);
        map.put('D',40);
    
        System.out.println(map);
        // map 迭代输出
        // for (Character ch: map.keySet()) {
        //     System.out.print(ch + " "); 
        //     Integer value = map.get(ch);
        //     System.out.println(value);
        // }
    }
}
```

## Stream

**常见的集合操作输出方法**

```java
package Stream;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * @ClassName StreamTest
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 21:19
 * @Version 1.0
 */

public class StreamTest {
    
    public static void main(String[] args) {
    
        Collection<String> collection = new ArrayList<>();
    
        Collections.addAll(collection, "张三丰", "张无忌", "周芷若");
    
        List<String> list = new ArrayList<>();
        System.out.println(collection);
    
        for (String names : collection) {
            if (names.startsWith("张")) {
                list.add(names);
            }
        }
    
        System.out.println(list);
    }
}
```

**使用流输出**

```java
package Stream;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

/**
 * @ClassName StreamFilter
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 21:24
 * @Version 1.0
 */

public class StreamFilter {
    public static void main(String[] args) {
    
        Collection<String> collection = new ArrayList<>();
    
        Collections.addAll(collection, "张三丰", "张无忌", "周芷若","张三");
        
        // 使用 Stream流 进行筛选
        collection.stream().filter(s -> s.length() == 3).filter(s -> s.startsWith("张")).forEach(s -> System.out.println(s));
    }
}
```

### 各个集合拿去流的方法

```java
package Stream;

import java.util.*;
import java.util.stream.Stream;

/**
 * @ClassName StreamTest
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 21:19
 * @Version 1.0
 */

public class StreamTest {
    
    public static void main(String[] args) {
    
        // 集合获取
       Collection<String> list = new ArrayList<>();
       
       Stream<String> s = list.stream();
        
       // Map 获取
        Map<String,Integer> map = new HashMap<>();
        
        Stream<String> KeyStream = map.keySet().stream();
        
        Stream<Integer> ValueStream = map.values().stream();
        
        Stream<Map.Entry<String,Integer>> KeyAndValue = map.entrySet().stream();
        
        // 获取数组
        
        String [] names = {"赵敏","小昭","灭绝","周芷若"};
        
        Stream<String> nameStream = Arrays.stream(names);
        
        Stream<String> name = Stream.of(names);
        
    }
}

```

## 异常

**出现异常如果没有处理就会导致程序终止，程序就会退出JVM虚拟机**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221216215837462.png" alt="image-20221216215837462" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221216223807924.png" alt="image-20221216223807924" style="zoom:80%;" />



### 异常分析

```java
package 异常;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 22:43
 * @Version 1.0
 */

public class Test {
    
    public static int divide(int a, int b){
        System.out.println(a);
        System.out.println(b);
        int c = a / b;
        System.out.println(c);
        
        return c;
    }
    public static void main(String[] args) {
    
        System.out.println("star");
        
        int ans = divide(10,0);
    
        System.out.println(ans);
        
        System.out.println("end");
    }
}
```

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221216224805578.png" alt="image-20221216224805578" style="zoom: 80%;" />

### 异常处理

#### throws Exception

```
但是这个抛出异常也会直接挂掉JVM
```



```java
package 异常;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

/**
 * @ClassName Expection_demo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 22:53
 * @Version 1.0
 */

public class Expection_demo {
    
    public static void main(String[] args) throws Exception {
    
        // 文件路径不存在  需要抛出一个异常1
        InputStream inputStream = new FileInputStream("f:]]");
    
        System.out.println("end");
        
    }
}
```

#### Try Catch

```java
package 异常;

import java.io.FileInputStream;
import java.io.FilterInputStream;
import java.io.InputStream;

/**
 * @ClassName Catch
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 22:56
 * @Version 1.0
 */

public class Catch {
    
    public static void main(String[] args) {
    
        // 使用 try Catch 执行 捕获异常 避免挂掉JVM
    
        try {
            InputStream inputStream = new FileInputStream("G;'''");
        } catch (Exception e) {
            System.out.println("文件不存在");
        }
    
        System.out.println("end");
    }
}

```

#### Try Catch和throws Exception结合

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221216231249009.png" alt="image-20221216231249009" style="zoom:67%;" />

```java
package 异常;

/**
 * @ClassName ExpectionAndCatch
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/16 23:08
 * @Version 1.0
 */

public class ExpectionAndCatch {
    
    public static int divide(int a, int b) throws Exception{
        
        int c = a / b;
        
        return c;
    }
    public static void main(String[] args) {
    
        int c = 0;
        
        try {
            c = divide(2,0);
            System.out.println("输出正常");
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("输出失败");
        }
        System.out.println("end 程序结束");        
    }
}

```

## 日志文件

### 日志

用来记录程序运行过程中的信息，并可以进行永久存储。

可以将系统执行的信息，方便的记录到指定的位置（控制台、文件中、数据库中）。

[日志文件地址]: https://logback.qos.ch/index.html



### Logback开发步骤

①：在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目库中去。
②：必须将Logback的核心配置文件logback.xml直接拷贝到src目录下。
③：在代码中获取日志的对象
④：使用日志对象输出日志信息 	

### 创建工程

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221217194223077.png" alt="image-20221217194223077" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221217194349146.png" alt="image-20221217194349146" style="zoom: 50%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221217194506144.png" alt="image-20221217194506144" style="zoom: 67%;" />

```java
package com.itheima;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/17 17:32
 * @Version 1.0
 */

public class Test {

    // 通过 LoggerFactory.getLogger 获取 当前类的 文件日志
    public static final Logger logger =  LoggerFactory.getLogger("Test.class");
    
    public static void main(String[] args) {
    
        while(true){
            try {
                logger.info("日志文件");
        
                int a = 10;
                int b = 0;
        
                logger.trace("a = " + a);
                logger.trace("b = " + b);
        
                int c = a / b;
        
                logger.error("出错了");
        
            } catch (Exception e) {
                e.printStackTrace();
                logger.error("error~~~");
            }
        }
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--
        CONSOLE ：表示当前的日志信息是可以输出到控制台的。
    -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!--输出流对象 默认 System.out 改为 System.err-->
        <target>System.out</target>
        <encoder>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度
                %msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n</pattern>
        </encoder>
    </appender>

    <!-- File是输出的方向通向文件的 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf-8</charset>
        </encoder>
        <!--日志输出路径-->
        <file>E:/Logback/Logback-data.log</file>
        <!--指定日志文件拆分和压缩规则-->
        <rollingPolicy
                class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!--通过指定压缩文件名称，来确定分割文件方式-->
            <fileNamePattern>E:/Logback/Logback-data2-%d{yyyy-MM-dd}.log%i.gz</fileNamePattern>
            <!--文件拆分大小-->
            <maxFileSize>1MB</maxFileSize>
        </rollingPolicy>
    </appender>

    <!--
    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR    |    ALL 和 OFF
   ， 默认debug
    <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。
    -->
    <root level="ALL">
        <!-- 注意：如果这里不配置关联打印位置，该位置将不会记录日志-->
        <appender-ref ref="FILE" />
        <appender-ref ref="CONSOLE" />
    </root>
</configuration>
```



## File

### 绝对路径 相对路径

```java
import java.io.File;

/**
 * @ClassName File
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/17 20:33
 * @Version 1.0
 */

public class File1 {
    
    public static void main(String[] args) {
    
        // 文件的相对路径
        File file = new File("src\\data.txt");
    
        System.out.println(file.length());
         
        // 文件的绝对路径
        String path = "E:\\大学两年的比赛和项目\\JavaSE\\JavaSE.txt";
        
        File file1 = new File(path);
    
        System.out.println(file1.length());
    }
}

```



### API

参考蓝桥杯Java手册详解

```
获取当前目录下所有的文件内容
```

```java
import java.io.File;

/**
 * @ClassName listFiles
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/17 21:20
 * @Version 1.0
 */

public class listFiles {
    
    public static void main(String[] args) {
    
        File file = new File("C:\\");
        
        File []list = file.listFiles();
    
        // System.out.println(list.length);
        
        for(int i = 0 ; i < list.length; i++){
            System.out.println(list[i]);
        }
        
    }
}

```

### 查找文件

```
通过java文件查找功能可以 迅速查找到 这个文件的目录位置
```



```java
import java.io.File;
import java.lang.reflect.Field;

/**
 * @ClassName 递归遍历时间
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/17 21:34
 * @Version 1.0
 */

public class 递归遍历时间 {

    public static void Search(File file, String fileName){

        if(file.isDirectory() == true && file != null){

            File []FileList = file.listFiles();
            
            // if(FileList == null) {
            //     System.out.println(file);
            // }
    
            /**
             *  if FileList is emptu
             *  FileList == null ==》 FileList is not exist address
             *  if FileList length is zero ==> FileList has address
             */
            if(FileList != null && FileList.length > 0){
                for(int i = 0 ; i < FileList.length; i++){
        
                    if(FileList[i].isFile() == true){
                        if(FileList[i].getName().contains(fileName) == true){
                            System.out.println("找到了" + FileList[i].getAbsolutePath());
                        }
                    }
                    else{
                        Search(FileList[i],fileName);
                    }
                }
            }
        }
        else{
            System.out.println("目录不存在");
        }
    }

    public static void main(String[] args) {

        String Path = "E:\\";
        String fileName = "211院校";

        File file = new File(Path);

        Search(file,fileName);
        
    }
}
```

## IO流

### [UTF-8,GBK,ANSI之间的关系和区别](https://www.cnblogs.com/myfrank/p/12857791.html)

GBK应该是属于ANSI之中的，在ANSI的国际通用集，GBK是专门来解决中文编码的，是双字节的，不论中英文都是双字节，而UTF-8是才用的另外的一种编码方式，对英文是用8位，对中文使用24位，是和ANSI和GBK 的编码方式是有本质区别的。我们记事本默认的保存时方式是ANSI，并且用不同的编码方式编写的文件必须用对应的编码格式来读取，否则就会出现乱码。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221219172755466.png" alt="image-20221219172755466" style="zoom:67%;" />

**ASCII字符集**

* 包括了数字、英文、符号。

* ASCII使用1个字节存储一个字符，一个字节是8位

**GBK**

* GBK是中国的码表，包含了几万个汉字等字符，同时也要兼容ASCII编码，
*  GBK编码中一个中文字符一般以两个字节的形式存储。

**Unicode字符集**

* 统一码，也叫万国码。是计算机科学领域里的一项业界标准。
* UTF-8是Unicode的一种常见编码方式。
  * UTF-8编码后一个中文一般以三个字节的形式存储，同时也要兼容ASCII编码表。
  * 技术人员都应该使用UTF-8的字符集编码。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221218133403851.png" alt="image-20221218133403851" style="zoom: 67%;" />

**IO编码和解码**

```java
import java.nio.charset.StandardCharsets;

/**
 * @ClassName String编码
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/18 13:34
 * @Version 1.0
 */

public class String编码 {
    
    public static void main(String[] args) {
        // 中文是以 负数开始的
        // 编码操作
        byte []arr = new byte[100];
        
        String info = "大家好!";
        
        // arr = info.getBytes("UTF-8");
    
        arr = info.getBytes(StandardCharsets.UTF_8);
        
        for(int i = 0 ; i < arr.length; i++){
            System.out.print(arr[i] + " ");
        }
        
        // 解码操作
        System.out.println();
        
        String getinfo = new String(arr);
    
        System.out.println(getinfo);
        
    }
    
}

```

![image-20221219110912877](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221219110912877.png)

![image-20221219110928313](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221219110928313.png)

![image-20221219111008133](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221219111008133.png)



![image-20221219111042201](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221219111042201.png)

### 字节输入流

```java
package 字节输入流;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

/**
 * @ClassName inputstream
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 11:12
 * @Version 1.0
 */

public class inputstream {
    
    public static void main(String[] args) throws Exception {
    
        // 定义一个文件路径
        String pathName = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\字节输入流\\文件输入流.txt";
        
        // 创建一个文件对象
        File file = new File(pathName);
    
        // 创建一个输入流
        InputStream inputStream = new FileInputStream(file);
        
        // // 读一个字节的数据
        // int msg = inputStream.read();
        //
        // System.out.println((char) msg);
        
        // // 循环读入
        // int msg;
        //
        // // 当文本内容读完了 返回 -1
        // while ((msg = inputStream.read()) != -1){
        //     System.out.print((char) msg);
        // }
        
    //    数组读入
        
        // byte[] buffer = new byte[1024]; // 定义一个1kb的字数组 读取文件
        //
        // int len = inputStream.read(buffer);
        //
        // for(int i = 0 ; i < len; i++){
        //     System.out.print((char)buffer[i]);
        // }

    }
}
```

### 字节输出流

```java
package 字节输出流;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStream;

/**
 * @ClassName outputStream
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 11:26
 * @Version 1.0
 */

public class outputStream {
    
    public static void main(String[] args) throws Exception {
        
        // 写入的文件路径
        String pathName = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\字节输出流\\data.txt";
    
        // 创建文件对象
        File file = new File(pathName);
    
        // append选项 表示 是否追加
        OutputStream outputStream = new FileOutputStream(file,true);
        
        // 写入一个字节
        
        char ch1 = 'a';
        
        outputStream.write(ch1);
        
        // 写入一个数组
        byte [] buffer = {'a','b','c','d'};
        
        outputStream.write(buffer);
        
        // 写入指定长度的 数组长度
        
        byte []buffer1 = {'1','2','3','4'};
        
        outputStream.write(buffer1,0,2);
        
        outputStream.flush();
        outputStream.close();
        
    }
    
}
```



### 文件复制

```java
package 文件拷贝;

import java.io.*;

/**
 * @ClassName CopyFile
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 11:34
 * @Version 1.0
 */

public class CopyFile {
    
    /**
     *  目标将 字节输入流中的文件拷贝到 文件拷贝这个文件中
     * @param args
     */
    public static void main(String[] args) throws Exception {
        
        // 1 将文件从文件输入流中读取出来
        
        String readPath = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\字节输入流\\文件输入流.txt";
    
        File file = new File(readPath);
    
        InputStream inputStream = new FileInputStream(file);
        // 写入 指定文件中去
        
        String writepathName = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\文件拷贝\\copy.txt";
        
        File file1 = new File(writepathName);
    
        OutputStream outputStream = new FileOutputStream(file1);
        
        // 循环读入
        // int msg;
        //
        // while((msg = inputStream.read()) != -1){
        //    
        //     outputStream.write(msg);
        //    
        // }
        // System.out.println("复制完成~~~");
        
        // 数组读入
        int len;
        
        byte []buffer = new byte[1024];
        
        while((len = inputStream.read(buffer)) != -1){
            
            outputStream.write(buffer,0,len);
            
        }
        
        System.out.println("复制完成~~~");
    }
    
}

```

### 字节流

* 字节流不要便读取打印，不同字符的 字节数量是不一样的
* 字节流对于文件复制是比较好的，复制过程是字节形式

### 异常处理

使用 finally 关闭资源

```java
package 异常处理;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * @ClassName 异常处理
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 13:10
 * @Version 1.0
 */

public class 异常处理 {
    
    public static void main(String[] args)  {
        int msg = 0;
    
        InputStream inputStream = null;
    
        try {
            // 定义一个文件路径
            String pathName = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\字节输入流\\文件输入流.txt";
        
            // 创建一个文件对象
            File file = new File(pathName);
        
            // 创建一个输入流
            inputStream = new FileInputStream(file);
        
            // 读一个字节的数据
            msg = inputStream.read();
    
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
    
            // 关闭管道 释放资源
            if(inputStream != null){
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
            
    }
}

```

在JDK 9改进中 自动释放资源

```java
package 异常处理;

/**
 * @ClassName 异常处理改进
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 13:16
 * @Version 1.0
 */

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * @ClassName 异常处理
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 13:10
 * @Version 1.0
 */

public class 异常处理改进 {
    
    public static void main(String[] args)  {
        
        int msg = 0;
        
        try(
            // try 中的内容是必须 继承资源都是实现了Closeable/AutoCloseable接口的类对象
                InputStream inputStream = new FileInputStream("E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\字节输入流\\文件输入流.txt");
            ) 
        {
            // 读一个字节的数据
            msg = inputStream.read();
    
            System.out.println("复制完成");
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 字符输入流

字符流解决读入数据乱码问题

#### Reader

```java
package 字符流;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.Reader;

/**
 * @ClassName 字符流
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 13:25
 * @Version 1.0
 */

public class 字符流 {
    
    public static void main(String[] args) throws Exception {
        
    //    1 将文本内容读出来
        
        String Path = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\字符流\\data";
    
        File file = new File(Path);
        
        Reader reader = new FileReader(file);
        
        // 每次读一个字符
        //
        // int len = reader.read();
        //
        // System.out.println((char)len);
    
        
    // //    循环读入
    //    
    //     int len;
    //     while((len = reader.read()) != -1){
    //
    //         System.out.print((char)len);
    //        
    //     }
        
        // 数组读入
        
        char []buffer = new char[1024];
        int len;
        
        while ((len = reader.read(buffer)) != -1){
    
            for(int i = 0 ; i < len; i++){
                System.out.print(buffer[i]);
            }
        }
    }
}

```

### 字符输出流

```java
package 字符输出流;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

/**
 * @ClassName writer
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 13:36
 * @Version 1.0
 */

public class writer {
    
    public static void main(String[] args) throws IOException {
        
    // 1 创建一个 文件
        
        String path = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\字符输出流\\data.txt";
    
        File file = new File(path);
    
        Writer writer = new FileWriter(file,true);
      
        // // 写入一个字符
        // writer.write('你');
        
        // // 写入一个数组
        // char []buffer = {'你','好','中','国'};
        //
        // writer.write(buffer);
      
        // 写入一个字符串
        String string = "我喜欢编程";
        
        writer.write(string,0,string.length());
    
        // 换行
        writer.write('\n');
        
        writer.flush();
        writer.close();
    
        System.out.println("写入完成~~");
    }
}
```

**字节流、字符流的使用场景总结？**
**字节流适合做一切文件数据的拷贝（音视频，文本）**
**字节流不适合读取中文内容输出**
**字符流适合做文本文件的操作（读，写）**

### 缓冲流

**作用：缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能**

**字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。**
**字节缓冲输出流自带了8KB缓冲池，数据就直接写入到缓冲池中去，写数据性能极高了。**

#### 字节缓冲输入流

##### BufferedInputStream

```java
String path = "E:\\智能车回忆及个人资料\\17届智能车 天翊\\8月26日\\Typecoh智能车生涯.mp4";
        
File file = new File(path);

InputStream inputStream = new FileInputStream(file);

BufferedInputStream in = new BufferedInputStream(inputStream);
```



#### 字节缓冲输出流

##### BufferedOutputStream

```java
String path1 = "E:\\智能车回忆及个人资料\\17届智能车 天翊\\8月26日\\Typecoh智能车生涯12.mp4";
    
 File file1 = new File(path1);

OutputStream outputStream = new FileOutputStream(file1);

BufferedOutputStream out = new BufferedOutputStream(outputStream); 
```





```java
package 缓冲流;

import java.io.*;
import java.nio.Buffer;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.Timer;

/**
 * @ClassName 字节缓冲输入流
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 15:30
 * @Version 1.0
 */

public class 字节缓冲输入流 {
    
    public static void main(String[] args) throws Exception {
        
        // 开始时间
        long starTime = System.currentTimeMillis();
        
        String path = "E:\\智能车回忆及个人资料\\17届智能车 天翊\\8月26日\\Typecoh智能车生涯.mp4";
        
        File file = new File(path);
    
        InputStream inputStream = new FileInputStream(file);
    
        BufferedInputStream in = new BufferedInputStream(inputStream);
    
        String path1 = "E:\\智能车回忆及个人资料\\17届智能车 天翊\\8月26日\\Typecoh智能车生涯12.mp4";
    
        File file1 = new File(path1);
        
        OutputStream outputStream = new FileOutputStream(file1);
    
        BufferedOutputStream out = new BufferedOutputStream(outputStream); 
        
        int len; 
        
        byte []buffer = new byte[1024];
        
        while((len = in.read(buffer)) != -1){
            
            out.write(buffer,0,len);
    
        }
        // 如果 不调用 close() 就会导致 缓冲区中部分 内容可能没用输入完成
        // 就会导致 文件残缺 视频播放不了
        
        out.close();
        
        // 结束时间
        long endTime = System.currentTimeMillis();
    
        System.out.println((endTime - starTime) / 1000.0 + "s");
        
        System.out.println("复制完成~~~");
        
    }
}

```



#### 字符缓冲输入流

##### BufferedReader

```java
String path = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\文件拷贝\\copy.txt";

File file = new File(path);

Reader reader = new FileReader(file);

BufferedReader br = new BufferedReader(reader);
```

#### 字符缓冲输出流

##### BufferedWriter

```java
String path1 = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\文件拷贝\\copy1.txt";

File file1 = new File(path1);

Writer writer = new FileWriter(file1);

BufferedWriter bw = new BufferedWriter(writer);
```

```java
package 缓冲流;

import java.io.*;

/**
 * @ClassName 字符缓冲输入输出流
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 16:50
 * @Version 1.0
 */

public class 字符缓冲输入输出流 {
    
    public static void main(String[] args) throws Exception {
        
        String path = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\文件拷贝\\copy.txt";
    
        File file = new File(path);
    
        Reader reader = new FileReader(file);
        
        BufferedReader br = new BufferedReader(reader);
        
        String path1 = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\文件拷贝\\copy1.txt";
        
        File file1 = new File(path1);
        
        Writer writer = new FileWriter(file1);
        
        BufferedWriter bw = new BufferedWriter(writer);
        
        String string;
        
        while((string = br.readLine()) != null){
    
            bw.write(string,0,string.length());
            // 换行
            bw.newLine();
        }
        
        bw.flush();
        br.close();
        
        System.out.println("输出完成");
    }
}

```

### 转换流

**当编码文件和代码编码不一致，会造成乱码**

**使用转换流解决这个问题**

#### 字符输入转化流

```java
String utf = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\转换流\\UTF-8.txt";

File file = new File(utf);

InputStream inputStream = new FileInputStream(file);

// 读文件是 utf-8
Reader reader = new InputStreamReader(inputStream,"UTF-8");
```

#### 字符输出转换流

```java
String ansi = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\转换流\\ANSI1.txt";

File file1 = new File(ansi);

OutputStream outputStream = new FileOutputStream(file1);

Writer writer = new OutputStreamWriter(outputStream,"GBK");
```

```java
package 转换流;

import java.io.*;
import java.nio.charset.StandardCharsets;

/**
 * @ClassName 字符输入转换流
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 17:09
 * @Version 1.0
 */

public class 字符输入转换流 {
    public static void main(String[] args) throws Exception {
        
        // String path = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\转换流\\data1.txt";
        //
        // File file = new File(path);
        //
        // InputStream inputStream = new FileInputStream(file);
        //
        // // 默认编码形式
        // // Reader reader = new InputStreamReader(inputStream);
        //
        // // 定义使用 编码 UTF-8
        // InputStreamReader reader = new InputStreamReader(inputStream, "GBK");
        //
        // int len = reader.read();
        //
        // System.out.println((char)len);
        //
        // System.out.println("输出完成~~~~");
        
        
        transport();
        
        
    }
    
    public static void transport() throws Exception{
        
        String utf = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\转换流\\UTF-8.txt";
        
        File file = new File(utf);
        
        InputStream inputStream = new FileInputStream(file);
        
        // 读文件是 utf-8
        Reader reader = new InputStreamReader(inputStream,"UTF-8");
        
        String ansi = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\转换流\\ANSI1.txt";
        
        File file1 = new File(ansi);
        
        OutputStream outputStream = new FileOutputStream(file1);
        
        Writer writer = new OutputStreamWriter(outputStream,"GBK");
        
        int len ;
        
        while((len = reader.read()) != -1){
            
            writer.write(len);
            
        }
        
        writer.close();
        reader.close();
    
        System.out.println("复制完成");
    }
}
```

### Properties	

其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。

**Properties核心作用：**	

* Properties代表的是一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。

* 属性文件：后缀是.properties结尾的文件,里面的内容都是 key=value，后续做系统配置信息的。

```java
package Properties;

import jdk.internal.util.xml.impl.Input;

import java.io.*;
import java.util.Properties;

/**
 * @ClassName properties
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 17:49
 * @Version 1.0
 */

public class properties {
    
    public static void main(String[] args) throws Exception {
        
        String path = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\Properties\\data.Properties";
    
        File file = new File(path);
    
        Writer writer = new FileWriter(file);
        
        Properties properties = new Properties();
        
        // 存储进去
        properties.setProperty("admin","里斯");
        properties.setProperty("admin1","里十大斯");
        properties.setProperty("admin2","里答斯");
        
        // 字符流存入
        properties.store(writer,"");
        
        // 获取对应的值
        String value = properties.getProperty("admin");
    
        System.out.println(value);
        
        System.out.println("存入完成");
    }
}

```

```java
package Properties;

import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import java.util.Properties;
import java.util.Set;

/**
 * @ClassName properties1
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/19 19:48
 * @Version 1.0
 */

public class properties1 {
    
    public static void main(String[] args) throws Exception {
    
        String path = "E:\\大学两年的比赛和项目\\JavaSE\\JavaFile\\src\\Properties\\data.Properties";
    
        File file = new File(path);
    
        Reader reader = new FileReader(file);
        
        Properties properties = new Properties();
        
        properties.load(reader);
        
        String value = properties.getProperty("admin1");
        
        // 获取 Key 集合
        Set<String> set =  properties.stringPropertyNames();
    
        for (String string:set) {
            System.out.println(string + " " + properties.getProperty(string));
        }
        System.out.println(value);
    }
}
```

| void load(InputStream inStream)                     | 从输入字节流读取属性列表（键和元素对）                       |
| --------------------------------------------------- | ------------------------------------------------------------ |
| void load(Reader reader)                            | 从输入字符流读取属性列表（键和元素对）                       |
| void store(OutputStream out, String comments)       | 将此属性列表（键和元素对）写入此 Properties表中，以适合于使用 load(InputStream)方法的格式写入输出字节流 |
| void store(Writer writer, String comments)          | 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 |
| public Object setProperty(String key, String value) | 保存键值对（put）                                            |
| public String getProperty(String key)               | 使用此属性列表中指定的键搜索属性值 (get)                     |
| public Set<String> stringPropertyNames()            | 所有键的名称的集合 (keySet())                                |

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221219200614101.png" alt="image-20221219200614101" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221219200622423.png" alt="image-20221219200622423" style="zoom: 67%;" />





## 线程

### 创建线程形式

#### 继承Thread类

```java
package 线程;

/**
 * @ClassName demo1
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/20 9:47
 * @Version 1.0
 */

public class demo1 {
    
    public static void main(String[] args) {
        
        Thread thread = new MyThread();
        // 调用 star方法 是 启动线程
        // 调用 run方法 是 执行方法
        thread.start();
    
        for(int i = 0 ; i < 100; i++)
        System.out.println("主线程运行");
        
    }
}

class MyThread extends Thread{
    @Override
    public void run() {
        for(int i = 0 ; i < 100; i++)
        System.out.println("子线程运行");
    }
}

```

#### 实现Runnable接口

```java
package 线程;

/**
 * @ClassName demo2
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/20 9:53
 * @Version 1.0
 */

public class demo2 {
    
    public static void main(String[] args) {
       
        // 创建一个Runnable 实现对象
        Runnable runnable = new MyThread1();
        //
        // // 将 Runnable 传给 Thread 类
        // Thread thread = new Thread(runnable);
        
        // 给子线程指定名称
        Thread thread = new Thread(runnable,"子线程");
        
        // 启动类
        thread.start();
    
        for(int i = 0 ; i < 100; i++){
            System.out.println("主线程运行");
        }
    }
}

class MyThread1 implements Runnable{
    
    // 存在的问题是 run 方法是没有返回值
    // 不利于实现业务程序
    @Override
    public void run() {
        for(int i = 0 ; i < 100; i++){
            System.out.println("子线程运行");
        }
    }
}
```

由于前两实现多线程 没有返回值 于是使用实现Callable接口

#### 实现Callable接口

```java
package 线程;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * @ClassName demo3
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/20 10:00
 * @Version 1.0
 */

public class demo3 {
    
    public static void main(String[] args) {
    
        // 创建第一个线程
        Callable<String> callable = new MyThread3(1000000); 
        
        FutureTask<String> futureTask = new FutureTask<>(callable);
        
        Thread thread = new Thread(futureTask);
    
        // 创建第二个线程
        Callable<String> callable2 = new MyThread3(50);
    
        FutureTask<String> futureTask2 = new FutureTask<>(callable2);
    
        Thread thread2 = new Thread(futureTask2);
    
        thread2.start();
        thread.start();
        

        // 拿到返回值
        try {
            String s1 = futureTask.get();
            System.out.println("第一个结果是" + s1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        
        // 拿到返回值
        try {
            String s2 = futureTask2.get();
            System.out.println("第二个结果" + s2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

class MyThread3 implements Callable<String>{
    
    private int num;
    
    public MyThread3(int num) {
        this.num = num;
    }
    
    @Override
    public String call() throws Exception {
        
        for(int i = 0; i < num; i++){
            System.out.println("子线程执行");
        }
        
        return "执行完成······························" + num;
    }
}
```

**优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。**
**可以在线程执行完毕后去获取线程执行的结果。**
**缺点：编码复杂一点。**

| 方式             | 优点                                                         | 缺点                                                   |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| 继承Thread类     | 编程比较简单，可以直接使用Thread类中的方法                   | 扩展性较差，不能再继承其他的类，不能返回线程执行的结果 |
| 实现Runnable接口 | 扩展性强，实现该接口的同时还可以继承其他的类。               | 编程相对复杂，不能返回线程执行的结果                   |
| 实现Callable接口 | 扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果 | 编程相对复杂                                           |

### 线程常用API

| 方法名称                               | 说明                                          |
| -------------------------------------- | --------------------------------------------- |
| String getName()                       | 获取当前线程的名称，默认线程名称是Thread-索引 |
| void setName(String name)              | 设置线程名称                                  |
| public static Thread currentThread()： | 返回对当前正在执行的线程对象的引用            |
| public static void sleep(long time)    | 让线程休眠指定的时间，单位为毫秒。            |
| public void run()                      | 线程任务方法                                  |
| public void start()                    | 线程启动方法                                  |

```java
package 线程.线程常用API;

/**
 * @ClassName demo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 10:07
 * @Version 1.0
 */

public class demo1 {
    
    public static void main(String[] args) {

        
        // 创建一个线程 对象
        Thread thread1 = new Mythread();
        // 给当前线程声明名字
        thread1.setName("线程1");
        
        // 创建第二个线程
        Thread thread2 = new Mythread();
        // 给当前线程声明名字
        thread2.setName("线程2");
        
        // 获取线程名字
        System.out.println("这个是线程1的名称" + thread1.getName());
    
        // 启动线程
        thread1.start();
        thread2.start();
    
        
    }
}

// 创建一个线程
class Mythread extends Thread{
  
    
    // 重写 run方法
    @Override
    public void run() {
        System.out.println(this.getName() + "正在执行");
    }
}
```

```java
package 线程.线程常用API;

/**
 * @ClassName demo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 10:07
 * @Version 1.0
 */

public class demo2 {
    
    public static void main(String[] args) throws Exception {

        
        //获取 Mythread2对象
        // public static Thread currentThread()：
        // 是一个静态方法是属于类本身的
        Thread thread = Mythread2.currentThread();
    
        System.out.println(thread);
        
        // 方法名称	说明
        // public static void sleep(long time)	让当前线程休眠指定的时间后再继续执行，单位为毫秒。
    
        Thread thread1 = new Mythread2();
        
        thread1.start();
        
    }
}

// 创建一个线程
class Mythread2 extends Thread{
  
    
    // 重写 run方法
    @Override
    public void run() {
        
        try {
            while(true){
                System.out.println("12");
                this.sleep(2000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### 线程安全

**多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题。**

**经典问题就是取钱问题**

**需求：小明和小红是一对夫妻，他们有一个共同的账户，余额是10万元。**
**如果小明和小红同时来取钱，而且2人都要取钱10万元，可能出现什么问题呢？**

#### 模拟安全问题

1 创建一个账户

```java
package 线程.线程安全;

public class Account {
    
    private String cardId;
    private double money; // 账户的余额
    
    public Account(){
        
    }
    
    public Account(String cardId, double money) {
        this.cardId = cardId;
        this.money = money;
    }
    
    /**
     小明 小红
     */
    public void drawMoney(double money) {
        // 0、先获取是谁来取钱，线程的名字就是人名
        String name = Thread.currentThread().getName();
        // 1、判断账户是否够钱
        if(this.money >= money){
            // 2、取钱
            System.out.println(name + "来取钱成功，吐出：" + money);
            // 3、更新余额
            this.money -= money;
            System.out.println(name + "取钱后剩余：" + this.money);
        }else {
            // 4、余额不足
            System.out.println(name +"来取钱，余额不足！");
        }
        
    }
    
    public String getCardId() {
        return cardId;
    }
    
    public void setCardId(String cardId) {
        this.cardId = cardId;
    }
    
    public double getMoney() {
        return money;
    }
    
    public void setMoney(double money) {
        this.money = money;
    }
    
}
```

2 模拟两个用户取钱行为

```java
package 线程.线程安全;

/**
 * @ClassName DrawThread
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 10:40
 * @Version 1.0
 */

public class DrawThread extends Thread{
    
    // 创建用户对象
    private Account account;
    
    public DrawThread(Account account ,String name) {
        // 给线程创建姓名
        super(name);
        // 创建当前用户
        this.account = account;
    }
    
    @Override
    public void run() {
        
        // 模拟取钱行为
        account.drawMoney(1000);
        
        
    }
}
```

3 创建两个取钱对象

```java
package 线程.线程安全;

/**
 * @ClassName demo2
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 10:44
 * @Version 1.0
 */

public class demo2 {
    
    public static void main(String[] args) {
        
        // 创建一个用户 在这个用户里面取钱
        Account account = new Account();
        
        account.setCardId("ICBC-111");
        account.setMoney(1000);
        
        // 创建两个进程 分别表示两个用户
        DrawThread red = new DrawThread(account,"小红");
        DrawThread white = new DrawThread(account,"小白");
        
        red.start();
        white.start();
    }
}
```

![image-20221221105749686](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221105749686.png)

出现异常，账户空亏空

![image-20221221110004883](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221110004883.png)

#### 解决安全问题

##### 1 同步代码块

**作用：把出现线程安全问题的核心代码给上锁。**

**原理：每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。**

```java
synchronized(同步锁对象) {

	操作共享资源的代码(核心代码)
}

```

同步锁对象的要求

规范上：

* 建议使用共享资源作为锁对象。
* 对于实例方法建议使用this作为锁对象。
* 对于静态方法建议使用字节码（类名.class）对象作为锁对象。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221125441031.png" alt="image-20221221125441031" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221130317697.png" alt="image-20221221130317697" style="zoom:80%;" />

**使用实例化方法使用的是this作为锁对象**

![image-20221221130731907](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221130731907.png)

```java
synchronized (this){
     if (this.money >= money) {
         // 2、取钱
         System.out.println(name + "来取钱成功，吐出：" + money);
         // 3、更新余额
         this.money -= money;
         System.out.println(name + "取钱后剩余：" + this.money);
     } else {    
         // 4、余额不足
         System.out.println(name + "来取钱，余额不足！");
     }
 }
```

**使用静态方法使用的是类名作为锁对象**

```java
/**
 * 使用静态方法 
 * 锁对象使用类名
 * 对于一个静态方法而言是属于类本身的 并不是属于类对象
 * 共享与所有类的
 */
public static void StaticMeathod(){
    // 没有创建出实例化对象 
    // 所以 this 没有指向
    // 锁对象更加建议使用 类名
    synchronized (Account1.class){
        
    }
}
```

##### 2 同步方法

```java
public synchronized void drawMoney(double money) {
    // 0、先获取是谁来取钱，线程的名字就是人名
    String name = Thread.currentThread().getName();
    // 1、判断账户是否够钱
    // 存在安全问题 上锁
    // synchronized (同步锁对象)
    // System.out.println(Thread.currentThread());
    // System.out.println(Thread.currentThread().getClass());

    // System.out.println(this);
    
        if (this.money >= money) {
            // 2、取钱
            System.out.println(name + "来取钱成功，吐出：" + money);
            // 3、更新余额
            this.money -= money;
            System.out.println(name + "取钱后剩余：" + this.money);
        } else {    
            // 4、余额不足
            System.out.println(name + "来取钱，余额不足！");
        }
}
```

![	](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221132612565.png)

##### 3 Lock锁

首先创建一个锁对象

```java
// 获得一个锁对象
private final Lock lock = new ReentrantLock();
```

给代码块进行上锁和解锁

为了避免死锁 使用 try finally

```java
// 上锁
lock.lock();

try {
    if (this.money >= money) {
        // 2、取钱
        System.out.println(name + "来取钱成功，吐出：" + money);
        // 3、更新余额
        this.money -= money;
        System.out.println(name + "取钱后剩余：" + this.money);

        System.out.println( 1 / 0);
    } else {    
        // 4、余额不足
        System.out.println(name + "来取钱，余额不足！");
    }
} finally {
    // 解锁
    lock.unlock();
}
```

### 进程通信

以消费者和生产者来讲，当生产者的这个进程在生产，消费者就处于等待状态；

以消费者和生产者来讲，当消费者的这个进程在消费，生产者就处于等待状态；

创建用户

```java
package 线程.线程通信;

/**
 * @ClassName Account
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 13:41
 * @Version 1.0
 */

public class Account {
    
    private String cardId;
    private double money;
    
    public Account() {
    }
    
    public Account(String cardId, double money) {
        this.cardId = cardId;
        this.money = money;
    }
    
    public String getCardId() {
        return cardId;
    }
    
    public void setCardId(String cardId) {
        this.cardId = cardId;
    }
    
    public double getMoney() {
        return money;
    }
    
    public void setMoney(double money) {
        this.money = money;
    }
    
    // 小红 小白取钱
    public synchronized void drawMoney(double money) {
        
        String name = Thread.currentThread().getName();
    
        if(this.money >= money){
            
            this.money -= money;
    
            System.out.println(name + "来取钱,剩下" + this.money);
        }
        else{
            // System.out.println(name + "来取钱" + "余额不足");
            try {
                // 把自己给上锁
                // 把其他人唤醒
                this.notifyAll();
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    // 存钱
    public synchronized void DepositMoney(double money) {
        // 获得当前进程名称
        String name = Thread.currentThread().getName();
    
        try {
            if(this.money == 0){
        
                this.money += money;
                System.out.println(name + "正在存钱" + "，余额" + this.money);
                
            }
            else{
                this.notifyAll();
                this.wait();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

消费者

```java
package 线程.线程通信;

/**
 * @ClassName DrawThread
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 13:45
 * @Version 1.0
 */

public class DrawThread extends Thread{
    
    private Account account;
    
    public DrawThread(Account acc, String name) {
        super (name);
        this.account = acc;
    }
    
    @Override
    public void run() {
        
        // 一直取钱
        while(true){
            try {
                account.drawMoney(1000);
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

生产者

```java
package 线程.线程通信;

/**
 * @ClassName DepositThread
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 13:59
 * @Version 1.0
 */

public class DepositThread extends Thread  {
    
    private Account account;
    
    public DepositThread(Account acc, String name) {
        super (name);
        this.account = acc;
    }
    
    @Override
    public void run() {
        
        // 一直取钱
        while(true){
            try {
                account.DepositMoney(1000);
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    } 
    
}
```

```java
package 线程.线程通信;

/**
 * @ClassName ThreadDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 13:44
 * @Version 1.0
 */

public class ThreadDemo {
    
    public static void main(String[] args) {
    //   创建一个Account
        Account account = new Account("ICBC-112",5000);
        
        new DrawThread(account,"小红").start();
        new DrawThread(account,"小白").start();
    
        new DepositThread(account,"亲爹").start();
        new DepositThread(account,"岳父").start();
        new DepositThread(account,"干爹").start();
        
    }
}
```

创建进程对象

```java
package 线程.线程通信;

/**
 * @ClassName ThreadDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 13:44
 * @Version 1.0
 */

public class ThreadDemo {
    
    public static void main(String[] args) {
    //   创建一个Account
        Account account = new Account("ICBC-112",5000);
        
        new DrawThread(account,"小红").start();
        new DrawThread(account,"小白").start();
    
        new DepositThread(account,"亲爹").start();
        new DepositThread(account,"岳父").start();
        new DepositThread(account,"干爹").start();
        
    }
}
```

### 线程池

线程池就是一个可以复用线程的技术。如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。

#### 创建线程池对象

##### 线程池处理Runnable任务

![image-20221221150843071](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221150843071.png)

```java
    /**
     * public ThreadPoolExecutor(
     *                           int corePoolSize,  // 线程核心数量
 *                               int maximumPoolSize, // 最多线程数
 *                               long keepAliveTime, //     临时线程存活时间
 *                               TimeUnit unit, //  存活时间的单位
 *                               BlockingQueue<Runnable> workQueue, // 任务队列
 *                               ThreadFactory threadFactory,  // 指定那个线程工厂创建线程
 *                               RejectedExecutionHandler handler //当线程忙的时候 任务满的时候 新任务来了 如何处理
     *                          )
     */

    ExecutorService executorService = new ThreadPoolExecutor(
                3,5,5, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10),
            Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy()
    );
```
**临时线程什么时候创建啊？**
**新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。**

**什么时候会开始拒绝任务？**

**核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。**

常见Runnable

```java
package 线程.线程池;

/**
 * @ClassName MyRunnable
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 14:57
 * @Version 1.0
 */

public class MyRunnable implements Runnable{
    @Override
    public void run() {
        
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + "输出了：HelloWorld ==> " + i);    
        }
        
    }
}

```

```java
package 线程.线程池;

import java.lang.reflect.Executable;
import java.util.concurrent.*;

/**
 * @ClassName 线程池对象
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 14:47
 * @Version 1.0
 */

public class 线程池对象 {
    
    public static void main(String[] args) {
    
        /**
         * public ThreadPoolExecutor(
         *                           int corePoolSize,  // 线程核心数量
     *                               int maximumPoolSize, // 最多线程数
     *                               long keepAliveTime, //     临时线程存活时间
     *                               TimeUnit unit, //  存活时间的单位
     *                               BlockingQueue<Runnable> workQueue, // 任务队列
     *                               ThreadFactory threadFactory,  // 指定那个线程工厂创建线程
     *                               RejectedExecutionHandler handler //当线程忙的时候 任务满的时候 新任务来了 如何处理
         *                          )
         */
    
        ExecutorService executorService = new ThreadPoolExecutor(
                    3,5,5, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(10),
                Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy()
        );
        
        Runnable target = new MyRunnable();
    
        //  核心三个线程，10个阻塞队列
        // 当需要处理的 进程数 小于等于13 不需要创建临时进程
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        executorService.execute(target);
        // 当进程数 大于 13 需要创建临时进程
        executorService.execute(target);
        executorService.execute(target);
       
        // 当进程数大于15 的时候 需要对新来的进程做处理 
        // handler 处理
        executorService.execute(target);

        
    }
}
```

| 策略                                   | 详解                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| ThreadPoolExecutor.AbortPolicy         | 丢弃任务并抛出RejectedExecutionException异常。**是默认的策略** |
| ThreadPoolExecutor.DiscardPolicy：     | 丢弃任务，但是不抛出异常 这是不推荐的做法                    |
| ThreadPoolExecutor.DiscardOldestPolicy | 抛弃队列中等待最久的任务 然后把当前任务加入队列中            |
| ThreadPoolExecutor.CallerRunsPolicy    | 由主线程负责调用任务的run()方法从而绕过线程池直接执行        |

##### **线程池处理Callable任务**

| 方法名称                           | 说明                                                   |
| ---------------------------------- | ------------------------------------------------------ |
| void execute(Runnable command)     | 执行任务/命令，没有返回值，一般用来执行 Runnable 任务  |
| Future<T> submit(Callable<T> task) | 执行Callable任务，返回未来任务对象获取线程结果         |
| void shutdown()                    | 等任务执行完毕后关闭线程池                             |
| List<Runnable> shutdownNow()       | 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务 |

创建一个ExecutorService 对象

```java
ExecutorService executorService = new ThreadPoolExecutor(
        3,5,5, TimeUnit.SECONDS,
        new ArrayBlockingQueue<>(10),
        Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy()
);
```

实现Callable接口

```java
package 线程.线程池;

import java.util.concurrent.Callable;

/**
 * @ClassName MyCallable
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 15:12
 * @Version 1.0
 */

public class MyCallable implements Callable {
    
    private int num;
    
    public MyCallable(int num) {
        
        this.num = num;
    }
    
    @Override
    public String call() throws Exception {
    
        int sum = 0;
        
        for (int i = 0; i < this.num; i++) {
            
            sum += i;
    
        }
        
        return Thread.currentThread().getName() + "执行结果是" + sum;
    }
}
```

获得 Callable返回值

```java
Future<String> f1 = executorService.submit(new MyCallable(100));
Future<String> f2 =  executorService.submit(new MyCallable(200));
Future<String> f3 = executorService.submit(new MyCallable(300));
Future<String> f4 = executorService.submit(new MyCallable(400));
```

输出结果

```java
String res1 = f1.get(); 
String res2 = f2.get(); 
String res3 = f3.get(); 
String res4 = f4.get();

System.out.println(res1);
System.out.println(res2);
System.out.println(res3);
System.out.println(res4);
```

```java
package 线程.线程池;

import java.util.concurrent.Callable;

/**
 * @ClassName MyCallable
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 15:12
 * @Version 1.0
 */

public class MyCallable implements Callable {
    
    private int num;
    
    public MyCallable(int num) {
        
        this.num = num;
    }
    
    @Override
    public String call() throws Exception {
    
        int sum = 0;
        
        for (int i = 0; i < this.num; i++) {
            
            sum += i;
    
        }
        
        return Thread.currentThread().getName() + "执行结果是" + sum;
    }
}
```

```java
package 线程.线程池;
import java.util.concurrent.*;

/**
 * @ClassName ExecutorService2
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 15:14
 * @Version 1.0
 */

public class ExecutorService2 {
    
    public static void main(String[] args) throws Exception {
    
            ExecutorService executorService = new ThreadPoolExecutor(
                    3,5,5, TimeUnit.SECONDS,
                    new ArrayBlockingQueue<>(10),
                    Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy()
            );
    
        Future<String> f1 = executorService.submit(new MyCallable(100));
        Future<String> f2 =  executorService.submit(new MyCallable(200));
        Future<String> f3 = executorService.submit(new MyCallable(300));
        Future<String> f4 = executorService.submit(new MyCallable(400));
    
        String res1 = f1.get(); 
        String res2 = f2.get(); 
        String res3 = f3.get(); 
        String res4 = f4.get();
    
        System.out.println(res1);
        System.out.println(res2);
        System.out.println(res3);
        System.out.println(res4);
    }
}
```

### 定时器

定时器是一种控制任务延时调用，或者周期调用的技术。
作用：闹钟、定时邮件发送。

#### 定时器的实现方式

##### Timer

```java
package 线程.定时器;
import java.util.Timer;
import java.util.TimerTask;

/**
 * @ClassName MyTimer
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 15:33
 * @Version 1.0
 */

public class MyTimer {
    
    public static void main(String[] args) {
    
        // 创建一个 定时器对象
        Timer timer = new Timer();
        
        TimerTask timerTask = new TimerTask() {
            @Override
            public void run() {
                System.out.println("say~~~");
            }
        };
        /**
         * 参数 1 任务对象
         * 参数 2 延时时间
         * 参数 3 周期时间
         */
        timer.schedule( timerTask,2000, 3000);
    }
}
```

可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221164241612.png" alt="image-20221221164241612" style="zoom:67%;" />



##### ScheduledExecutorService

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221165402804.png" alt="image-20221221165402804" style="zoom: 67%;" />

**当其中一个定时器发生异常时，不会影响其他定时器**

```java
package 线程.定时器;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @ClassName MyScheduledExecutorService
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 16:43
 * @Version 1.0
 */

public class MyScheduledExecutorService {
    
    public static void main(String[] args) {
    
        // 创建 ScheduledExecutorService 定时器
        // 拿到了Executors 的方法 newScheduledThreadPool  规定了 最大数量是多少
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);
        
        pool.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "hello~~~~");
            }
        },2,2, TimeUnit.SECONDS);
    
        pool.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "say~~~~");
            }
        },2,2, TimeUnit.SECONDS);
        pool.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "world~~~~");
                System.out.println(1 / 0);
            }
        },2,2, TimeUnit.SECONDS);
    
    }
}
```

### 并发和并行

#### 并发

单核CPU处理器在处理进程中

CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221165904907.png" alt="image-20221221165904907" style="zoom:67%;" />	

#### 并行

多核处理器CPU

在处理进程时，多个进程可以同时被处理

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221170034571.png" alt="image-20221221170034571" style="zoom:67%;" />

### 生命周期

![image-20221221170141579](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221170141579.png)

| NEW(新建)               | 线程刚被创建，但是并未启动。                                 |
| ----------------------- | ------------------------------------------------------------ |
| Runnable(可运行)        | 线程已经调用了start()等待CPU调度                             |
| Blocked(锁阻塞)         | 线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态；。  |
| Waiting(无限等待)       | 一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒 |
| Timed Waiting(计时等待) | 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep 、Object.wait。 |
| Teminated(被终止)       | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 |

## 网络编程

#### 网络地址操作

##### InetAddress 使用

获取IP地址对象

| public static InetAddress getLocalHost()             | 返回本主机的地址对象                               |
| ---------------------------------------------------- | -------------------------------------------------- |
| **public static InetAddress getByName(String host)** | **得到指定主机的IP地址对象，参数是域名或者IP地址** |

```java
// 获取本地IP地址对象
InetAddress ip1 = InetAddress.getLocalHost();

InetAddress ip2 = InetAddress.getByName("www.baidu.com");
```

| **public String getHostName()**    | **获取此IP地址的主机名** |
| ---------------------------------- | ------------------------ |
| **public String getHostAddress()** | **返回IP地址字符串**     |

```java
// 输出本机用户名称
String name = ip1.getHostName();
System.out.println(ip1.getHostName());

// 获取本机地址
String Adress = ip1.getHostAddress();
System.out.println(ip1.getHostAddress());
```

| public boolean isReachable(int timeout) | 在指定毫秒内连通该IP地址对应的主机，连通返回true |
| --------------------------------------- | ------------------------------------------------ |
|                                         |                                                  |

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221171821902.png" alt="image-20221221171821902" style="zoom:67%;" />

```java
// 表示 本地 带到 ip地址是否可以到达
Boolean isrechable = ip2.isReachable(1000);

System.out.println(isrechable);
```



#### UDP通信

##### 1 单一通信

发送方

* 创建发送方

```java
// 创建发送方
// 指定发送方的 端口号
DatagramSocket sender = new DatagramSocket(6666);
```

* 创建发送的数据

```java
   //   创建发送的数据
    
   // 数据数组
   byte []buffer = "我是发送方的发送数据".getBytes();
    
        /**
         *     public DatagramPacket(byte buf[], int length,
         *                           InetAddress address, int port) 
         *                           
         *                           参数1 buffer 数组
         *                           参数2 长度
         *                           参数3 本地主句ip地址
         *                           参数4 端口号
         *                           参数3 + 参数4 ===》 套接字（Socket）
         */
    
   DatagramPacket data = new DatagramPacket(buffer,buffer.length,InetAddress.getLocalHost(),8080);
```



* 进行发送

```java
//    发送
sender.send(data);
```

* 释放资源

```java
// 释放资源
sender.close();
```

```java
package 网络编程.UDP通信;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

/**
 * @ClassName ClientDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 21:14
 * @Version 1.0
 */

public class ClientDemo {
    
    public static void main(String[] args) throws Exception {
        
         // 创建发送方
        // 指定发送方的 端口号
        DatagramSocket sender = new DatagramSocket(6666);
        
        //   创建发送的数据
    
        // 数据数组
        byte []buffer = "我是发送方的发送数据".getBytes();
    
        /**
         *     public DatagramPacket(byte buf[], int length,
         *                           InetAddress address, int port) 
         *                           
         *                           参数1 buffer 数组
         *                           参数2 长度
         *                           参数3 本地主句ip地址
         *                           参数4 端口号
         *                           参数3 + 参数4 ===》 套接字（Socket）
         */
    
        DatagramPacket data = new DatagramPacket(buffer,buffer.length,
                InetAddress.getLocalHost(),8080);
        
    //    发送
        sender.send(data);
        
        // 释放资源
        sender.close();
    }
    
}
```

接收发

* 创建接收方

```java
// 创建接收方
DatagramSocket reciver = new DatagramSocket(8080);
```

* 接收发送方发送的数据

```java
// 创建接收方
DatagramSocket reciver = new DatagramSocket(8080);

// 创建发送的数据

// 数据数组
byte []buffer = new byte[1024];

DatagramPacket data = new DatagramPacket(buffer,buffer.length);
```

* 接收数据显示

```java
 // 接收数据
reciver.receive(data);

// 求出 长度
int len = data.getLength();
// 取出数据
String res = new String(buffer,0,len);

System.out.println("收到的数据 === " + res);

// 拿到发送发的 ip地址
String SendIp = data.getSocketAddress().toString();

System.out.println(SendIp);

// 拿到发送方的 端口

int Port = data.getPort();
System.out.println(Port);
```

* 释放资源

```java
// 释放资源
reciver.close();
```

```java
package 网络编程.UDP通信;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketAddress;

/**
 * @ClassName ServiceDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 21:14
 * @Version 1.0
 */

public class ServiceDemo {
    
    public static void main(String[] args) throws Exception {
    
    
        // 创建接收方
        DatagramSocket reciver = new DatagramSocket(8080);
    
        // 创建发送的数据
    
        // 数据数组
        byte []buffer = new byte[1024];
    
        DatagramPacket data = new DatagramPacket(buffer,buffer.length);
    
        // 接收数据
        reciver.receive(data);
        
        // 求出 长度
        int len = data.getLength();
        // 取出数据
        String res = new String(buffer,0,len);
    
        System.out.println("收到的数据 === " + res);
        
        // 拿到发送发的 ip地址
        String SendIp = data.getSocketAddress().toString();
    
        System.out.println(SendIp);
        
        // 拿到发送方的 端口
        
        int Port = data.getPort();
        System.out.println(Port);
    
        // 释放资源
        reciver.close();
    }
}
```



##### 2 多发多收

发送方

```java
package 网络编程.UDP通信.多发多收;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.util.Scanner;

/**
 * @ClassName ClientDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 21:14
 * @Version 1.0
 */

public class ClientDemo {
    
    public static void main(String[] args) throws Exception {
        
    //    创建发送方
        DatagramSocket sender = new DatagramSocket(6666);
    
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("=====客户端启动了======");
    //    多次发送数据
        
        while (true){
    
            System.out.println("请说: ");
            //   创建发送的数据
            String sendString = scanner.next();
            
            if(sendString.equals("exit")){
                System.out.println("离线成功！");
                break;
            }
            // 数据数组
            byte []buffer = sendString.getBytes();
    
            /**
             *     public DatagramPacket(byte buf[], int length,
             *                           InetAddress address, int port) 
             *
             *                           参数1 buffer 数组
             *                           参数2 长度
             *                           参数3 本地主句ip地址
             *                           参数4 端口号
             *                           参数3 + 参数4 ===》 套接字（Socket）
             */
    
            DatagramPacket data = new DatagramPacket(buffer,buffer.length,
                    InetAddress.getLocalHost(),8080);
    
            sender.send(data);
        }
        
        sender.close();
    }
    
}
```

```java
package 网络编程.UDP通信.多发多收;

import java.net.DatagramPacket;
import java.net.DatagramSocket;

/**
 * @ClassName ServiceDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 21:14
 * @Version 1.0
 */

public class ServiceDemo {
    
    public static void main(String[] args) throws Exception {
    
    
        // 创建接收方
        DatagramSocket reciver = new DatagramSocket(8080);
    
        System.out.println("=====服务端启动了======");
    
        while(true){
            // 创建发送的数据
    
            // 数据数组
            byte []buffer = new byte[1024];
    
            DatagramPacket data = new DatagramPacket(buffer,buffer.length);
    
            // 接收数据
            reciver.receive(data);
    
            //    求出 长度
            int len = data.getLength();
            //    取出数据
            String res = new String(buffer,0,len);
    
            // 拿到发送发的 ip地址
            String SendIp = data.getSocketAddress().toString();
    
            // 拿到发送方的 端口
            int Port = data.getPort();
    
            System.out.println("收到来自：" + data.getSocketAddress().toString() + ",端口号是" + data.getPort() + ",消息是" + res);
        }
    }
}
```

idea设置

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221220745108.png" alt="image-20221221220745108" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221220800317.png" alt="image-20221221220800317" style="zoom:80%;" />

![image-20221221220811617](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221220811617.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221221220819806.png" alt="image-20221221220819806" style="zoom:80%;" />



### UDP通信方式

#### 广播

将ip地址换成了 （255.255.255.255）

```java
DatagramPacket data = new DatagramPacket(buffer,buffer.length,
        InetAddress.getByName("255.255.255.255"),8080);
```

接收方和发送方端口一致就可以

#### 组播

发送方

发送目标的ip地址改成组播地址

```java
DatagramPacket data = new DatagramPacket(buffer,buffer.length,
        InetAddress.getByName("224.0.1.1"),8080);
```

接收方而言

1 MulticastSocket

```java
// 创建接收方
MulticastSocket reciver = new MulticastSocket(8080);
```

2 加入组播地址

```java
reciver.joinGroup(new InetSocketAddress(InetAddress.getByName("224.0.1.1"),8080),
        NetworkInterface.getByInetAddress(InetAddress.getLocalHost())
);
```

### TCP通信	

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222143625560.png" alt="image-20221222143625560" style="zoom: 67%;" />

客户端和服务端进行通信通过管道将数据进行传输

#### 一发一收

创建管道进行连接

```java
Socket socket = new Socket("127.0.0.1",7777);
```

获得管道数据

```java
//    从socket管道中 得到字节输出流 负责发送数据
    OutputStream os = socket.getOutputStream();
    
//    将低级的字节流包装成打印流

    PrintStream ps = new PrintStream(os);
```

发送数据

```java
//    发送小心
    ps.println("TCP的客户端，发送请求");
    ps.flush();
```

接收方

创建接收对象

```java
// 常见ServiceSocket对象
ServerSocket serverSocket = new ServerSocket(7777);
```

进行连接

```java
// 等到连接
Socket socket = serverSocket.accept();
```

从管道中读取数据

```java
// 连接完成之后 拿取数据  
InputStream in =  socket.getInputStream();

Reader reader = new InputStreamReader(in);

BufferedReader br = new BufferedReader(reader);
```

将数据输出

```java
String msg;
// 接收方是 接收一行数据 所以发送方必须是发送一行数据
// 必须加上换行符
// 将while 改成 if 就是 一发一收
if((msg = br.readLine())!= null){
    System.out.println(socket.getRemoteSocketAddress() + ":" + msg);
}
```

客户端完整代码

```java
package 网络编程.TCP.一发一收;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.net.Socket;

/**
 * @ClassName ClientDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 23:01
 * @Version 1.0
 */

public class ClientDemo {
    
    public static void main(String[] args) throws Exception {
        
        // 创建客户端
    
        System.out.println("=====客户端启动======");
        /**
         * 参数1 服务1 的ip地址
         * 参数2 端口号
         */
        
        Socket socket = new Socket("127.0.0.1",7777);
        
    //    从socket管道中 得到字节输出流 负责发送数据
        OutputStream os = socket.getOutputStream();
        
    //    将低级的字节流包装成打印流
    
        PrintStream ps = new PrintStream(os);
        
    //    发送小心
        ps.println("TCP的客户端，发送请求");
        ps.flush();
    }
}
```

```java
package 网络编程.TCP.一发一收;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.Buffer;

/**
 * @ClassName ServiceDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 23:10
 * @Version 1.0
 */

public class ServiceDemo {
    
    public static void main(String[] args) throws Exception {
    
        System.out.println("=====服务端启动======");
        // 常见ServiceSocket对象
        ServerSocket serverSocket = new ServerSocket(7777);
        
        // 等到连接
        Socket socket = serverSocket.accept();
        
        // 连接完成之后 拿取数据  
        InputStream in =  socket.getInputStream();
    
        Reader reader = new InputStreamReader(in);
    
        BufferedReader br = new BufferedReader(reader);
        
        String msg;
        // 接收方是 接收一行数据 所以发送方必须是发送一行数据
        // 必须加上换行符
        // 将while 改成 if 就是 一发一收
        if((msg = br.readLine())!= null){
            System.out.println(socket.getRemoteSocketAddress() + ":" + msg);
        }
        
        
    }
    
}
```



#### 多发多收

N-N

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222144150450.png" alt="image-20221222144150450" style="zoom:67%;" />

客户端每次发送一个请求，服务端就创建一个新的进程

```java
while(true){
    
    // 等到连接
    Socket socket = serverSocket.accept();
    
    // 对于每一个 都启动线程
    new MyServiceThread(socket).start();
}
```

```java
package 网络编程.TCP.多发多收.多线程;

import java.io.OutputStream;
import java.io.PrintStream;
import java.net.Socket;
import java.util.Scanner;

/**
 * @ClassName ClientDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 23:01
 * @Version 1.0
 */

public class ClientDemo {
    
    public static void main(String[] args) throws Exception {
    
        Scanner scanner = new Scanner(System.in);
        
        // 创建客户端
    
        System.out.println("=====客户端启动======");
        /**
         * 参数1 服务1 的ip地址
         * 参数2 端口号
         */
        Socket socket = new Socket("127.0.0.1",7777);
    
        //    从socket管道中 得到字节输出流 负责发送数据
        OutputStream os = socket.getOutputStream();
    
        //    将低级的字节流包装成打印流
    
        PrintStream ps = new PrintStream(os);
        
        while (true){
    
            System.out.println("请说：");
            //发送的消息
            String send = scanner.nextLine();
            
            //    发送小心
            ps.println(send);
            ps.flush();
        }
    }
}
```

```java
package 网络编程.TCP.多发多收.多线程;

import java.io.*;
import java.net.Socket;

/**
 * @ClassName MyServiceThread
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 14:05
 * @Version 1.0
 */

public class MyServiceThread extends Thread{
    
    private Socket socket;
    
    public MyServiceThread(Socket  socket){
        this.socket = socket;
    }
    
    @Override
    public void run() {
    
        // 连接完成之后 拿取数据  
        try {
            InputStream in =  this.socket.getInputStream();
        
            Reader reader = new InputStreamReader(in);
        
            BufferedReader br = new BufferedReader(reader);
        
            String msg;
            // 接收方是 接收一行数据 所以发送方必须是发送一行数据
            // 必须加上换行符
            // 将while 改成 if 就是 一发一收
            while((msg = br.readLine())!= null){
                System.out.println(this.socket.getRemoteSocketAddress() + ":" + msg);
            }
        } catch (IOException e) {
    
            System.out.println(this.socket.getRemoteSocketAddress() + "下线了");
        }
    
    }
}
```

```java
package 网络编程.TCP.多发多收.多线程;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * @ClassName ServiceDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 23:10
 * @Version 1.0
 */

public class ServiceDemo {
    
    public static void main(String[] args) throws Exception {
    
        System.out.println("=====服务端启动======");
        // 常见ServiceSocket对象
        ServerSocket serverSocket = new ServerSocket(7777);
        
        // 对于每个接收数据 创建一个子线程
        
        while(true){
            
            // 等到连接
            Socket socket = serverSocket.accept();
            
            // 对于每一个 都启动线程
            new MyServiceThread(socket).start();
        }
    }
}
```

#### 线程池

![image-20221222144340090](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222144340090.png)

引入线程池，分别进行数据排队处理

```java
package 网络编程.TCP.多发多收.线程池;

import java.io.OutputStream;
import java.io.PrintStream;
import java.net.Socket;
import java.util.Scanner;

/**
 * @ClassName ClientDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 23:01
 * @Version 1.0
 */

public class ClientDemo {
    
    public static void main(String[] args) throws Exception {
    
        Scanner scanner = new Scanner(System.in);
        
        // 创建客户端
    
        System.out.println("=====客户端启动======");
        /**
         * 参数1 服务1 的ip地址
         * 参数2 端口号
         */
        Socket socket = new Socket("127.0.0.1",7777);
    
        //    从socket管道中 得到字节输出流 负责发送数据
        OutputStream os = socket.getOutputStream();
    
        //    将低级的字节流包装成打印流
    
        PrintStream ps = new PrintStream(os);
        
        while (true){
    
            System.out.println("请说：");
            //发送的消息
            String send = scanner.nextLine();
            
            //    发送小心
            ps.println(send);
            ps.flush();
        }
    }
}
```

```java
package 网络编程.TCP.多发多收.线程池;

import java.io.*;
import java.net.Socket;

/**
 * @ClassName MyServiceRunnable
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 14:21
 * @Version 1.0
 */

public class MyServiceRunnable implements Runnable{
    
    private Socket socket;
    
    public MyServiceRunnable(Socket socket) {
        this.socket = socket;
    }
    
    @Override
    public void run() {
        // 连接完成之后 拿取数据  
        try {
            InputStream in =  this.socket.getInputStream();
        
            Reader reader = new InputStreamReader(in);
        
            BufferedReader br = new BufferedReader(reader);
        
            String msg;
            // 接收方是 接收一行数据 所以发送方必须是发送一行数据
            // 必须加上换行符
            // 将while 改成 if 就是 一发一收
            while((msg = br.readLine())!= null){
                System.out.println(this.socket.getRemoteSocketAddress() + ":" + msg);
            }
        } catch (IOException e) {
        
            System.out.println(this.socket.getRemoteSocketAddress() + "下线了");
        }
    }
}
```

```java
package 网络编程.TCP.多发多收.线程池;

import 网络编程.TCP.多发多收.多线程.MyServiceThread;

import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @ClassName ServiceDemo
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/21 23:10
 * @Version 1.0
 */

public class ServiceDemo {
    
    public static ExecutorService pool = new ThreadPoolExecutor(3,5,3, 
            TimeUnit.SECONDS,new LinkedBlockingDeque<>(),new ThreadPoolExecutor.AbortPolicy());
    
    public static void main(String[] args) throws Exception {
    
        System.out.println("=====服务端启动======");
        // 常见ServiceSocket对象
        ServerSocket serverSocket = new ServerSocket(7777);
        
        // 对于每个接收数据 创建一个子线程
        
        while(true){
            
            // 等到连接
            Socket socket = serverSocket.accept();
    
            // 创建 target  创建多个线程
            MyServiceRunnable target = new MyServiceRunnable(socket);

            pool.execute(target);
            
        }
    }
}
```

## Junit单元测试

Junit单元测试就是用来测试

| @Test        | 测试方法                                                     |
| ------------ | ------------------------------------------------------------ |
| @Before      | 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。 |
| @After       | 用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。 |
| @BeforeClass | 用来静态修饰方法，该方法会在所有测试方法之前只执行一次。     |
| @AfterClass  | 用来静态修饰方法，该方法会在所有测试方法之后只执行一次。     |

使用@Test注解进行测试代码，不用创建main方法进行测试

## 反射

#### 概念

**反射是指对于任何一个Class类，在"运行的时候"都可以直接得到这个类全部成分**

或者说在运行中我们可以

* 可以直接得到这个类的构造器对象：Constructor
* 可以直接得到这个类的成员变量对象：Field
* 可以直接得到这个类的成员方法对象：Method

**这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。**

#### 反射获取

**反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。**

#### 获取类对象

```java
// 方式1 通过类名.class方式
Class c1 = Student.class;

// 方式2 通过对象.getClass()

Class c2 = new Student().getClass();

System.out.println(c1);
System.out.println(c2);
```

#### 使用反射获取构造器

目的：通过反射获取构造器，拿到构造器之后就进行创建对象	

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222151913371.png" alt="image-20221222151913371" style="zoom:80%;" />

| 方法                                                         | 说明                                       |
| ------------------------------------------------------------ | ------------------------------------------ |
| Constructor<?>[] getConstructors()                           | 返回所有构造器对象的数组（只能拿public的） |
| Constructor<?>[] getDeclaredConstructors()                   | 返回所有构造器对象的数组，存在就能拿到     |
| Constructor<T> getConstructor(Class<?>... parameterTypes)    | 返回单个构造器对象（只能拿public的）       |
| Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) | 返回单个构造器对象，存在就能拿到           |

1 获取类对象

```java
  // 拿到反射类
        Class c2 = new Student().getClass();
```

2 拿到构造器

```java
 //  拿到所有的构造器

    Constructor [] constructors = c2.getDeclaredConstructors();

    for (Constructor con:constructors) {
        System.out.println(con.getName());
    }
    
    //只拿到public 构造器
    Constructor []constructor = c2.getConstructors();
    for (Constructor con:constructor) {
        System.out.println(con.getName());
    }
    
//    拿到单一的构造器
    Constructor one = c2.getConstructor();

    System.out.println(one);

    //    拿到单一的构造器 参数的类型的类
    Constructor one1 = c2.getConstructor(int.class,int.class);

    System.out.println(one1);
```

3 创建新的类对象

```java
// 通过无参构造器获取一个对象

// 如果获取的是一个私有的话 就要使用暴力反射
// 将权限打开
one.setAccessible(true);

Student student = (Student)one.newInstance();

System.out.println(student);
```

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222155008029.png" alt="image-20221222155008029" style="zoom:80%;" />



#### 使用反射获取变量

| 方法                                | 说明                                         |
| ----------------------------------- | -------------------------------------------- |
| Field[] getFields()                 | 返回所有成员变量对象的数组（只能拿public的） |
| Field[] getDeclaredFields()         | 返回所有成员变量对象的数组，存在就能拿到     |
| Field getField(String name)         | 返回单个成员变量对象（只能拿public的）       |
| Field getDeclaredField(String name) | 返回单个成员变量对象，存在就能拿到           |

| 符号                                 | 说明     |
| ------------------------------------ | -------- |
| void set(Object obj, Object value)： | 赋值     |
| Object get(Object obj)               | 获取值。 |



```java
package 反射;

import java.lang.reflect.Field;

/**
 * @ClassName 获取方法
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 15:51
 * @Version 1.0
 */

public class 获取方法 {
    
    public static void main(String[] args) throws Exception {
        
    //    1 获取类
        Class c = Student.class;
        
    //    2 获取变量
        Field [] fields = c.getDeclaredFields();
    
        for (Field filed: fields) {
            System.out.println(filed.getName());
        }
        
    //    3给变量取值和赋值
        
        Field Name = c.getDeclaredField("name");
        // 暴力反射
        Name.setAccessible(true);
        
        // 创建一个Student对象
        Student s = new Student();
        
        // 给创建的这个对象 赋值
        Name.set(s,"张三");
    
        // 拿取刚才赋值完成的那个值
        System.out.println(Name.get(s));
    
    }
}
```

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222160605088.png" alt="image-20221222160605088" style="zoom:80%;" />

#### 使用反射获取方法

| 方法                                                         | 说明                                         |
| ------------------------------------------------------------ | -------------------------------------------- |
| Method[] getMethods()                                        | 返回所有成员方法对象的数组（只能拿public的） |
| Method[] getDeclaredMethods()                                | 返回所有成员方法对象的数组，存在就能拿到     |
| Method getMethod(String name, Class<?>... parameterTypes)    | 返回单个成员方法对象（只能拿public的）       |
| Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到           |

| 符号                                      | 说明                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| Object invoke(Object obj, Object... args) | 运行方法参数一：用obj对象调用该方法参数二：调用方法的传递的参数（如果没有就不写）返回值：方法的返回值（如果没有就不写） |

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222161429739.png" alt="image-20221222161429739" style="zoom:80%;" />

```java
package 反射;

import java.lang.reflect.Method;

/**
 * @ClassName 获取方法
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 16:06
 * @Version 1.0
 */

public class 获取方法 {
    
    public static void main(String[] args) throws Exception {
        
        Class c = Student.class;
    
        Method method = c.getDeclaredMethod("getName");
        
        // 执行这个方法
        
        Student s = new Student();
        
        String ans = (String)method.invoke(s);
    
        System.out.println(ans);
    }
}
```

#### 反射的作用-绕过编译阶段为集合添加数据

在书写中 将String类型变量加入到Integer中出错

在编译过程中 String 和Integer都是指向 ArrayList 是被认同的

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(100);
// list.add(“黑马"); // 报错
list.add(99);
```

反射是作用在编译阶段的，所用通过反射可以给不同类型指定数据

## 注解

**对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。**

自己自定一个注解

```java
    package 注解.自定义注解;

/**
 * @ClassName MyBook
 * @Description TODO
 * @Author lenovo
 * @Date 2022/12/22 16:34
 * @Version 1.0
 */

public @interface MyBook {
    
    public String name();
    
    public String authors();
    
    double price();
    
}

```

使用注解

```java
package 注解.自定义注解;

/**
 * @ClassName 自定义注解
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 16:32
 * @Version 1.0
 */
@MyBook(name = "heima",authors = "ty",price = 20)
public class 自定义注解 {
    @MyBook(name = "heima",authors = "ty",price = 20)
    public static void main(String[] args) {
        @MyBook(name = "heima",authors = "ty",price = 20)
        int age = 20;
    }
}
```

**特殊属性**
**value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!**
**但是如果有多个属性,  且多个属性没有默认值，那么value名称是不能省略的。**

#### 元注解

注解的注解

![image-20221222170554570](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222170554570.png)

![image-20221222170610441](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222170610441.png)



#### 注解解析

**注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。**

**与注解解析相关的接口**

* Annotation: 注解的顶级接口，注解都是Annotation类型的对象
* AnnotatedElement:该接口定义了与注解解析相关的解析方法

| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Annotation[]  getDeclaredAnnotations()                       | 获得当前对象上使用的所有注解，返回注解数组。                 |
| T getDeclaredAnnotation(Class<T> annotationClass)            | 根据注解类型获得对应注解对象                                 |
| boolean isAnnotationPresent(Class<Annotation> annotationClass) | 判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false |

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222171053923.png" alt="image-20221222171053923" style="zoom:80%;" />



```java
package 注解.注解解析;
import java.awt.print.Book;
import java.lang.reflect.Method;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 17:13
 * @Version 1.0
 */

public class Test {
    
    public static void main(String[] args) throws Exception {
        
        // 拿到类对象
        Class c = MyBook.class;
    
        System.out.println(c);
        
        // 拿取类的方法 反射
        Method method = c.getDeclaredMethod("say");
        
        Boolean is = method.isAnnotationPresent(Bookstore.class);
    
        if(is == true){
            
        //    拿到注解对象
            Bookstore bookstore = (Bookstore) c.getDeclaredAnnotation(Bookstore.class);
      	// 输出注解对象的内容
            System.out.println(bookstore.name());
            System.out.println(bookstore.say());
        }
    }
}

@Bookstore(name = "张三",say = "hello")
class MyBook {
    
    private String name;
    private Double price;
    
    @Bookstore(name = "张三",say = "hello")
    public String say(){
        System.out.println("hello world");
        return "hello world!";
    }
}
```



```java
package 注解.注解解析;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @ClassName Bookstore
 * @Description TODO
 * @Author lenovo
 * @Date 2022/12/22 17:13
 * @Version 1.0
 */
// 限制注解的位置
@Target({ElementType.TYPE,ElementType.METHOD})
// 限制 运行时间 如果没有规定的话 就会无效
@Retention(RetentionPolicy.RUNTIME)
public @interface Bookstore {
    
    public String name();
    
    public String say();
    
}
```

#### 注解具体使用

**通过注解和反射实现自动执行方法**

创建一个注解

```java
package 注解.整合Junit;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @ClassName Service
 * @Description TODO
 * @Author lenovo
 * @Date 2022/12/22 19:48
 * @Version 1.0
 */
// 限制注解的位置
@Target({ElementType.TYPE,ElementType.METHOD})
// 限制 运行时间
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTest {
}
```

给方法加上注解

```java
@MyTest
public void say1(){
    System.out.println("hello say1");
}
@MyTest
public void say2(){
    System.out.println("hello say2");
}

public void say3(){
    System.out.println("hello say3");
}
```

通过反射哪方法

```java
public static void main(String[] args) throws Exception {
    

    // 获取 类对象
    Test test = new Test();
    
    //  反射第一步 获取 类
    Class c = test.getClass();
    
    // 获取方法
    Method []methods = c.getDeclaredMethods();
    
    for(Method method : methods){
        
    //    遍历每一个方法
        if(method.isAnnotationPresent(MyTest.class) == true){
        //    执行这个方法
            method.invoke(test);
        }
    }
}
```

```java
package 注解.整合Junit;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 19:48
 * @Version 1.0
 */

public class Test {
    
    @MyTest
    public void say1(){
        System.out.println("hello say1");
    }
    @MyTest
    public void say2(){
        System.out.println("hello say2");
    }
    
    public void say3(){
        System.out.println("hello say3");
    }
    
    public static void main(String[] args) throws Exception {
        
    
        // 获取 类对象
        Test test = new Test();
        
        //  反射第一步 获取 类
        Class c = test.getClass();
        
        // 获取方法
        Method []methods = c.getDeclaredMethods();
        
        for(Method method : methods){
            
        //    遍历每一个方法
            if(method.isAnnotationPresent(MyTest.class) == true){
            //    执行这个方法
                method.invoke(test);
            }
        }
    }
}
```



## 动态代理

![image-20221222203534392](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222203534392.png)

**通过代理可以简化一部分重复的操作**

**可以在不改变方法源码的情况下，实现对方法功能的增强。**

```java
package Proxy;


import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @ClassName Proxy
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 20:20
 * @Version 1.0
 */

public class MyProxy {
    
    public static Service getProxy(ServiceImpl obj){
    
        /**
         *    public static Object newProxyInstance(ClassLoader loader,
         *                                           Class<?>[] interfaces,
         *                                           InvocationHandler h)
         * 参数1 加载器 需要做代理对象的.getclass().getClassLoader()                                        
         * 参数2 接口 obj.getClass().getInterfaces(),
         * 参数3 处理器 InvocationHandler
         */
        // 返回一个代理对象
        return (Service) Proxy.newProxyInstance(obj.getClass().getClassLoader(),
                obj.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    
                        System.out.println("开始选择");
                        Object res = method.invoke(obj,args);
                        System.out.println("选择完成");
                        return res;
                    }   
                });
        
    }
}
```

```java
package Proxy;

/**
 * @ClassName Test
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 20:09
 * @Version 1.0
 */

public class Test {
    
    public static void main(String[] args) {
        
        // 创建一个实例话对象 service
        ServiceImpl service = new ServiceImpl();
        
        // 创建一个接口对象 service1
        Service service1 = MyProxy.getProxy(service);
        
        service1.selectUsers();
        
    }
}
```

```java
package Proxy;

/**
 * @ClassName Service
 * @Description TODO
 * @Author lenovo
 * @Date 2022/12/22 20:08
 * @Version 1.0
 */

public interface Service {
    
    String login(String loginName , String passWord) ;
    
    void selectUsers();
    
    boolean deleteUsers();
    
    void updateUsers();
    
}
```

```java
package Proxy;

/**
 * @ClassName ServiceImpl
 * @Description TODO
 * @Author Typecoh
 * @Date 2022/12/22 20:09
 * @Version 1.0
 */

public class ServiceImpl implements Service{
    
    @Override
    public String login(String loginName, String passWord) {
        return null;
    }
    
    @Override
    public void selectUsers() {
        System.out.println("根据Users进行选择");
    }
    
    @Override
    public boolean deleteUsers() {
        return false;
    }
    
    @Override
    public void updateUsers() {
        
    }
}
```

## XML

**XML的全称为（EXtensible Markup Language），是一种可扩展的标记语言。它是是一种数据表示格式，可以用于自定义数据格式。**

用处：

* 用于进行存储数据和传输数据
* 作为软件的配置文件

XML语法规则：

* XML文件的后缀名为：xml
* 文档声明必须是第一行

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222204345797.png" alt="image-20221222204345797" style="zoom:50%;" />

XML语法规则

* 标签由一对尖括号和合法标识符组成: <name></name>，必须存在一个根标签，有且只能有一个。
* 标签必须成对出现，有开始，有结束: <name></name>
* 特殊的标签可以不成对，但是必须有结束标记，如:<br/>
* 标签中可以定义属性，属性和标签名空格隔开,属性值必须用引号引起来<student id = “1"></name>

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222204514051.png" alt="image-20221222204514051" style="zoom:80%;" />

**XML文件中可以存在CDATA区: <![CDATA[   …内容…  ]]>**



#### XML文档约束

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221222205248010.png" alt="image-20221222205248010" style="zoom:80%;" />







## 加密算法

### MD5加密

常见函数

#### MessageDigest

MD5中实体类，调用方法对数据进行加密操作

### getInstance

指定使用的对象加密算法对象是什么：MD

```java
getInstance("MD5")
```

### digest

一旦所需要更新的数据都已经被更新后,应该调用digest() 方法完成Hash计算。
对于给定数量的更新数据 ,digest() 方法只能被调用一次.在调用digest() 方法之后,MessageDigest对象被重新设置成初始状态。

```java
/**
 * 通过执行诸如填充之类的最终操作完成Hash计算. 
 * 在调用此方法之后,摘要被重置
 *
 * @return byte[] Hash计算后的byte数组
 */
public byte[] digest();

digest(string.getBytes("UTF-8"))
```

### String.getBytes(String decode)

String.getBytes(String decode)方法会根据指定的decode编码返回某字符串在该编码下的byte数组表示

```java
String name = "hello";
byte[] bytes = name.getBytes("UTF-8");

for(byte b : bytes){
    System.out.println(b);
}

/**
104
101
108
108
111
*/
```

[手把手教你 bytes[i\] & 0xFF 原理详解-CSDN博客](https://blog.csdn.net/xuedengyong/article/details/81386225)

    1.byte的取值范围
    
    byte java 中一个字节 8位 即 -2^7—2^7-1  范围是 -128——127 (*对这个有疑问吗？在2 中解答)
    
    2.计算机中负数的存储的值是它的补码
    
       补码计算方法  负数取值是它的绝对值，的二进制数，取反，加1，那么对于-128——-1的存储 就知道了吧
    
    举个例子 -12   绝对值------> 12就是0000  1100  取反------> 1111 0011 加 1  1111 0100 (晓得不)
    
    那么-128——127  就可以理解了-128 是绝对值 128  二进制-------->  1000 0000   取反  0111 1111（127）  加1  ，1000 0000 （128）
    
    -1 的绝对值 是  1   0000 0001  取反  1111 1110 加1   1111 1111 （255） 
    
    计算机 中   -128——-1 对应存储的是   128-255  
    
    再看 2^7-1  也就是127 刚好 是0111 1111  为啥减1  因为 128 已经被占了 所以  
    
    -128——127  在数据库中真实存的是   128——255  外加  0——127   也就是 byte真正在计算机中存储范围是 
    
    0——255 只不过我们说的是它的取值范围  是 -128——127
    
    3.byte 转 int 16进制 （int  -2^31——2^31-1）
    
    bytes[i] & 0xFF
    
    byte和int运算，计算机会自动将 byte转化为32位，然后再运算，也就是8位转32位，那么计算机会自动将高位补1
    
    所以-12 在计算机种就是    1111 0011--------> 1111 1111 1111 1111 1111 1111 1111 0100
    
    然后 &  0xFF     
    0x 代表16进制   每一位取值范围是  0 —— 15 
    
    但是 10——15之间是两位数字了，会和10进制分部开 所以 10——15就对应了 A——F
    
    那么0xFF 就是   0000 0000 0000 0000 0000 0000 1111 1111 
    
    &运算  得到 0000 0000 0000 0000  0000 0000  1111 0100

有没有发现什么？低八位  1111 0011  没有改变 ，那么为什么  &  0xFF而不是别的呢？

  原因就是 byte 转int 前24位都被计算机强制 变成了1，    1111 1111 1111 1111 1111 1111 1111 0100 转化成int已经不是

-12在计算机中存储的值了，&  0xFF   0000 0000 0000 0000 0000 0000 1111 1111 恰好前24位都是 0，进行&运算，只会保留

低八位，也就是byte中原来在计算机中存储的值  1111 0100。






```java
for (byte b : hash) {
    if ((b & 0xFF) < 0x10) hex.append("0");
    hex.append(Integer.toHexString(b & 0xFF));
}
```



